/**
 * 关于js中 ==与===的区别总结
 * 
 * */ 

//  引语
// 众所周知，用在if条件判断语句中，js有六种假值：false, null, undefined, '', NAN, 0。
// 在用作条件语句判断条件时候，==与===存在一些差异，分别总结如下：

/**
 * 
 * ===
 * 1.如果类型不同，就[不相等]
 * 2.如果两个都是数值，并且是同一个值，那么[相等]；（例外的是），如果其中至少一个是NaN,那么[不相等]
 * **存在 NaN === NaN false 不相等
 * **（判断一个值是否是NaN，只能用isNaN()来判断）
 * 3.如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。
 * 4.如果两个值都是true，或者都是false，那么[相等]。
 * 5.如果两个值都是null，或者都是undefined，那么[相等]。
 * 6.引用类型比较，进行“指针地址”比较，如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。\
 * 
 * 
 * 存在在问题：
 * 1.NaN不等于自身
 * 2.+0等于-0
*/



/**
 * 
 * ==
 * 一、如果两个值类型相同，进行 === 比较。
 * 二、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：
 * ***
 * 1.如果一个是null、一个是undefined，那么相等。null == undefined
 * 2.如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。
 * 3.如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。
 * 4.如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 
 * **js核心内置类，会尝试valueOf先于toString。
 * **例外的是Date，Date利用的是toString转换。
 * 
 * 
 * 存在的问题：
 * 1.自动转换数据类型
 * 2.null == undefined
 * 
 * */ 



/**
 * 
 * ES6解决方案：Object.is()
 * ES6 提出“Same-value equality”（同值相等）算法，用来解决===存在的问题。
 * 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
 * 
 * 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
*/

// ES5 可以通过下面的代码，部署Object.is。
Object.defineProperty(Object, 'is', {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x && y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});