### 关于javascript的尾调用尾递归的理解
---

##### [一、尾调用]()

即在函数执行末尾调用另一个函数或者函数自身

##### [二、递归]()

如果一个函数在内部调用自身本身，这个函数就是递归函数

一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回

例子：实现一个函数 pow(x, n)，它可以计算 x 的 n 次方
```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
```

##### [三、尾递归]()

尾递归，即在函数尾位置调用自身，尾递归也是递归的一种特殊情形。

尾递归在普通尾调用的基础上，多出了2个特征：
- 在尾部调用的是函数自身
- 可通过优化，使得计算仅占用常量栈空间

在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出

这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误

实现一下阶乘，如果用普通的递归，如下：

```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
```

如果n等于5，这个方法要执行5次，才返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出，因为每次递归调用都有对上次函数变量n的引用,复杂度为O(n)

如果我们使用尾递归，则如下：

```js
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```

可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。尾递归只需要保存一个调用栈，复杂度 O(1)