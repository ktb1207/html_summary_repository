/**
 * 
 * 关于js内存管理和垃圾回收机制
 * */ 

// 概念
// ----内存泄漏：不再用到的内存，没有及时释放，就叫做内存泄漏。
// ----垃圾回收机制：与c语言这种底层语言不同，JavaScript并没有提供内存管理的接口，
//      而是在创建变量时自动分配内存，当变量不再需要使用时自动释放，也就是我们所常说的垃圾回收机制。
// ----javascript内存空间：JavaScript内存空间分为栈，堆，池，队列。
// ----栈：存放变量，基本类型数据与指向复杂类型数据的引用指针；
// ----堆：存放复杂类型数据；
// ----池：又称为常量池，用于存放常量；
// ----队列：在任务队列也会使用；


// 数据结构
// ----栈：数据结构具备FILO（first in last out）先进后出的特性，较为经典的就是乒乓球盒结构，
//        先放进去的乒乓球只能最后取出来。
// ----堆：数据结构是一种无序的树状结构，同时它还满足key-value键值对的存储方式；
//        我们只用知道key名，就能通过key查找到对应的value。
// ----队列：具有FIFO（First In First Out）先进先出的特性，
//          与栈内存不同的是，栈内存只存在一个出口用于数据进栈出栈；而队列有一个入口与一个出口


// js 自动内存回收
/**
 * 在js中，垃圾回收器每隔一段时间就会找出那些不再使用的数据，并释放其所占用的内存空间。
 * 如：
 * 以全局变量和局部变量来说，函数中的局部变量在函数执行结束后这些变量已经不再被需要，所以垃圾回收器会识别并释放它们。
 * 而对于全局变量，垃圾回收器很难判断这些变量什么时候才不被需要，所以尽量少使用全局变量。
 * */ 


// js 垃圾回收两种模式--引用计数--标记清除
/**
 * 引用计数：
 * 原理：引用计数的判断原理很简单，就是看一份数据是否还有指向它的引用，如果没有任何对象再指向它，那么垃圾回收器就会回收
 * 
 * 存在问题：对于对象间的循环引用，垃圾回收器通过引用计数也无法释放它们。
 * */ 

/**
 * 标记清除
 * 原理：从根部出发看是否能达到某个对象，如果能达到则认定这个对象还被需要，如果无法达到，则释放它
 * 步骤：
 * 1.垃圾回收器创建roots列表，roots通常是代码中保留引用的全局变量，在js中，我们一般认定全局对象window作为root，也就是所谓的根部。
 * 2.从根部出发检查所有 的roots，所有的children也会被递归检查，能从root到达的都会被标记为active。
 * 3.未被标记为active的数据被认定为不再需要，垃圾回收器开始释放它们。
 * 
 * 优势：当一个对象零引用时，我们从根部一定无法到达；但反过来，
 *      从根部无法到达的不一定是严格意义上的零引用，比如循环引用，
 *      所以标记清除要更优于引用计数。
 * */ 


// 如何避免内存泄漏？
/**
 * 1.全局变量
 * 尽可能少的去创建全局变量是js开发者的常识
 * 如：
 * a:在函数中声明变量未使用var：
 * function fn() {
 *  a = 1;
 * };
 * fn();
 * window.a // 1
 * 
 * b:在函数体内通过this来创建变量：
 * function fn() {
 *  this.a = 1;
 * };
 * fn();
 * window.a //1
 * 解决方式：使用严格模式来避免这个问题，试着在代码头部添加‘use strict’，你会发现a就无法访问了，
 *          因为严格模式下，全局对象指向undefined。
 * */ 

/**
 * 2.被遗忘的定时器或回调函数
 * */ 

/**
 * 3.闭包--对于闭包中的变量，在不需要时一定记得手动释放。
 * */ 

/**
 * 4.DOM的引用
 * 
 * 操作dom总是被认为是不好的，但一定得操作，
 * 我们的习惯是通过一个变量来存储它，这样就可以反复使用了，但这也会造成一个问题，dom会被引用2次。
 * 
 * var elements = document.getElementById('button')
 * function doStuff() {
 *  elements.innerHTML = '听风是风';
 * };
 * 
 * // 清除引用
 * elements = null;
 * document.body.removeChild(document.getElementById('button'));
 * 一次引用是基于dom树的引用，第二是变量elements的引用，当我们不需要这个dom时，都做两次清除操作。
 * */ 


/**
 * 5.通过WeakMap解决内存泄漏问题
 * 定义：WeakMap对象保存键值对，与Map不同的是其键必须是对象，因为键是弱引用，在键对象消失后自动释放内存。
 * 
 * 当使用Dom对象绑定事件时，Dom对象消失后若没有及时释放内存（置null），便会一直存在内存中。
 * 使用WeakMap保存Dom对象不会出现这样的问题，因为Dom对象消失后，JS的垃圾回收机制便会自动释放其所占用的内存。
 * 
 * <button type="button" id="btn">按钮</button>
 * let wm = new WeakMap();
 * let btn = document.querySelector('#btn');
 * wm.set(btn, {count: 0});
 * btn.addEventListener('click', () => {
 *  let v = wm.get(btn);
 *  v.count++;
 *  console.log(wm.get(btn).count);
 * });
 * */ 
